\section{Experiments}

TODO introduction

\subsection{Setup}


We run Spark 2.4.0.
We use Scala 2.11.12 on Java openJDK 1.8.

So far, we run three different join algorithms.
Our sequential implementation of Leapfrog Triejoin (see~\cref{ssec:seq}), called \texttt{seq}.
Spark's two different binary join algorithms: \texttt{BroadcastHashJoin} and \texttt{SortMergeJoin}.
In the majority of our experiments we use Spark in its standard configuration with enabled code generation.
We also tune the parameters for driver and executor memory usage (\texttt{spark.driver.memory} and \texttt{spark.executor.memory}) to fit all necessary data into the cache.
We adjust the \texttt{"spark.sql.autoBroadcastJoinThreshold"} parameter to control if Spark is using a \texttt{BroadcastHashJoin} or a \texttt{SortMergeJoin}.

\subsubsection{Hardware}

We run our experiments on machines of the type \texttt{brick} of the Scilens cluster of the CWI Database Architecture research group.
These machines feature 32 Intel Xeon E5-2650 processors with a 32 KB 1st level cache, 250 KB 2nd level cache and 20 MB of shared third level cache and run at 2.0 to 2.8 GHz.
The machines are equipped with 256 GB of RAM DDR-3 memory.

% TODO how many machines? 16, but how many could we use, etc.
% TODO network


\subsubsection{Datasets}
We run our the majority of our experiments on two datasets from different use-cases, social networks and product purchase.
We motivate our choice in the next paragraph.
\Cref{table:datasets} includes a whole list of all graph datasets mentioned throughout the thesis.

\begin{table}[]  % TODO make booktab style
    \begin{tabular}{lllll}
        Name    & Variant & Vertices & Edges & Source          \\
        SNB     & sf1     &          &       & \cite{snb}      \\
        Amazon  & 0302    &          &       & \cite{snapnets} \\
                & 0601    &          &       & \cite{snapnets} \\
        Twitter & sc-d    &          &       & \cite{snapnets} \\
                & sc-u    &          &       & \cite{snapnets}
    \end{tabular}
    \caption{Summary of all datasets mentioned in the thesis.
      Explanation of them and for the variants is given in running text.
    }
    \label{table:datasets}
\end{table}

% TODO add Vertices and edges numbers

The SNB benchmark~\cite{snb} generates data emulating the posts, messages and friendships in a social network.
For our experiments we use only the friendships relationship (\texttt{person\_knows\_person.csv}) which is an undirected relationship.
After generation only edges of the kind \textit{src $\le$ dst} exist, we generate the opposing edges before loading the dataset, such that the edge table we run our experiments
on is truely undirected.
The benchmark comes with an extensively parameterizable graph generation engine
which allows us to experiment with sizes as small as 1GB and up to 1TB for big experiments and different levels of selectivity.
The different sizes are called scale-factor or \texttt{sf}, e.g. \texttt{SNB-sf-1} refers to a Social network benchmark dataset generated with
default parameters and scale-factor 1.
We include the exact parameter used for generation in our repository under \texttt{experiments/snb/params.txt}. % CODEREF TODO include

The Amazon co-purchasing network contains edges between products that have been purchased together and hence are closely related to each other~\cite{snapnets}.
This is a directed relationship from the product purchased first to the product purchased second, both direction of an edge can exist if the order in which
products have been purchased varies.
The Snap dataset collection contains multiple Amazon co-purchase datasets each of them containing a single day of purchases.
We choose the smallest and biggest dataset from the 2nd of March and the 1st of June, we call them \texttt{Amazon-0302} and \texttt{Amazon-0601}.
We pick them for evaluation because former work often concentrated on social networks and web crawl based graphs~\cite{myria-detailed,ammar2018distributed}
while~\cite{salihoglu2018} points out that the biggest graphs are actually graphs graphs like the aforementioned Amazon graph containing purchase information.

To allow comparisions with former work, we run a subset of our experiments on the Twitter social circle network from~\cite{snapnets}.
This dataset includes the follower relationship of one thousand twitter users each of these follows 10 to 4.964 other users and relationship between these are included.
The graph is originally directed but for some experiments we add reversed edges to make the graph undirected - again for comparision with former work.
We call this graph \texttt{Twitter-sc-d} and \texttt{Twitter-sc-u} for the directed respectively undirected variant.

\subsubsection{Graph patterns}

In this section we detail the graph patterns used thoughout our experiments.
Most of the queries are cyclic because that has been shown to be the primary use-case for WCOJ in former research~\cite{olddog,myria-detailed}.
WCOJ also have been successfully applied to selective path queries in~\cite{olddog}; these results have not been reproduced by any other paper.

To most of our queries we apply also some kind of filter to make them more realistic, e.g. a clique query does make more sense if it is combined with a
smaller-than filter requiring that the attributes are bound such that \textit{a} smaller than \textit{b} smaller than \textit{c}, otherwise
one gets the same clique in all possible orders as result, which not only takes much more time but is also most likely not the result a user would want.
We ensure that filters can be pushed down through or in the join by Spark as well as by the WCOJ to compare both algorithms on equal basis.
A complete list of all queries and filters used is shown in~\cref{table:patterns}.
The less known queries are also detailed in text.
Patterns and filters might be used in all possible combinations, we name the resulting query \textit{\textless pattern\textgreater-\textless filter\textgreater}, e.g. \textit{triangle-lt}.

\begin{table}[]
    \begin{tabular}{@{}lcccp{6cm}@{}}
        \toprule
        Name     & Parameters                 & Vertices & Edges             & Example Datalog                                                                                                                                        \\ \midrule
        \texttt{triangle} & NA                          & $3$        & 3                 & a $\rightarrow$ b; a $\rightarrow$ c; b $\rightarrow$ c                                                                                                \\
        \texttt{n-clique} & \# vertices                & $n$        & $1/2 \times n \times (n - 1)$ & see above                                                                                                                                              \\
        \texttt{n-cycle}  & \# vertices                & $n$        & $n$                 & a $\rightarrow$ b; b $\rightarrow$ c; c $\rightarrow$ z; z $\rightarrow$ a                                                                             \\
        \texttt{n-s-path} & \# edges / selectivity  & $n$       & $n - 1$             & a $\rightarrow$ b; b $\rightarrow$ c; c $\rightarrow$ z                                                                                                \\
        \texttt{diamond}  & NA                         & $4$       & $5$                 & a $\rightarrow$ b; a $\rightarrow$ c; b $\rightarrow$ c; b $\rightarrow$ d; c $\rightarrow$ d                                                          \\
        \texttt{house}    & NA                         & $5$        & $9$                 & a $\rightarrow$ b; a $\rightarrow$ c; a $\rightarrow$ d; b $\rightarrow$ c; b $\rightarrow$ d; c $\rightarrow$ d; c $\rightarrow$ e; d $\rightarrow$ e \\
        \textbf{Filters}   &                            &          &                   &                                                                                                                                                        \\
        \texttt{distinct} &                            &          &                   & a $\neq$ b; a $\neq$ c; a $\neq$ d; b $\neq$ c; ...                                                                                                                    \\
        \texttt{lt}       &                            &          &                   & a \textless b; b \textless c; c \textless d; ...                                                                                                       \\ \bottomrule
    \end{tabular}
    \caption{Summary of patterns and filters used.}
    \label{table:patterns}
\end{table}
% TODO is that a dimaond?

For a selective path query, we first select two sets of nodes with respect to the \textit{selectivity} parameter.
Then we search for all path of a certain length according to the \textit{edges} parameter, e.g. \textit{4-0.1-path} finds all
paths between two randomly selected, fixed sets of vertices of length 4 - the sets of nodes contain roughly 10\% of all input nodes and are not guaranteed to be intersection free.
% TODO do I want them to be intersection free?

\subsection{Baseline: \texttt{BroadcastHashJoin} vs \texttt{seq}}

\begin{figure}
    \centering
    \includesvg{seq-bar-ama0302}
    \caption{\texttt{seq} vs \texttt{BroadcastHashJoin} on \texttt{Amazon-0302}}
    \label{fig:seq-bar-ama-0302}
\end{figure}

\begin{figure}
    \centering
    \includesvg{seq-bar-ama0601}
    \caption{\texttt{seq} vs \texttt{BroadcastHashJoin} on \texttt{Amazon-0601}}
    \label{fig:seq-bar-ama-0601}
\end{figure}

\begin{figure}
    \centering
    \includesvg{seq-bar-snb-sf1}
    \caption{\texttt{seq} vs \texttt{BroadcastHashJoin} on \texttt{SNB-sf1}}
    \label{fig:seq-bar-snb-sf1}
\end{figure}

% Spark setup code line
% define measurements times
% show DAG's for both algorithms in terms of DAG
% argue why WCOJ times against whole times
% argue why broadcast merge join and not sortmerge join

% measure if spark actually takes more than 30 minutes on long queries

% measure path queries



% tabulate results
% Bar charts such that scaling of axis is readable


% measure against none code generated spark, notice in sentence
% measure against Sortmerge join, notice in sentence

% comparision against other work
%   Dewitt
%   Andreas Amler
%   Old dog
%   LFTJ
%   Richard