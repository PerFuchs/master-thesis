\section{Implementation}\label{sec:implementation}

\subsection{General sequential version (\texttt{seq})}\label{subsec:general-sequential-versiontexttt}
We implement the Leapfrog Triejoin~\cite{leapfrog} as our general sequential version of a WCOJ.
However, instead of using B-Trees as a backing data structure, we use sorted arrays and a binary search
to for its backing, which has been described in~\cite{myria-detailed} and is called Tributary join in their paper.
Our Leapfrog Triejoin is implemented in three components, which we explain in this order below: \texttt{LeapfrogJoin}, \texttt{ArrayTrieIterable} and
\texttt{LeapfrogTriejoin}.

The Leapfrog join is a variant of the sort-merge join for unary relationships, original described in~\cite{leapfrog1,leapfrog2}. % TODO see LFTJ paper 4 and 7
To join $k$ unary relations $A_1(x)$, $A_2(x)$, \dots, $A_k(x)$ it takes one iterator per input relations and offers an iterator
interface that yields the intersection of all relations.
It requires that it's input iterators offer a \textit{key} method in $\mathcal{O}(1)$, a \textit{next} method and
a \textit{least\_upper\_bound(key: Int)} both in $\mathcal{O} (\log n)$ ($n$ defined as the size of the input relationship).
\textit{least\_upper\_bound} moves the iterator to the first position of the sought \textit{key} or the first position of the
next higher value.
An idiotmatic implementation of a Leapfrog join is shown in~\cref{lst:leapfrog-join}, for the optimized implementation see
\texttt{leapfrogTriejoin.LeapfrogJoin} in our repository.  % CODEREF

\begin{listing}[H]
    \inputminted{scala}{code/LeapfrogJoin.scala}
    \caption{Leapfrog join.}
    \label{lst:leapfrog-join}
\end{listing}

To support j-arity relations, $A(a_1, a_2, \dots, a_j)$ we add two methods to the iterator interface that represents the input
relationships: \textit{up} and \textit{down} both are required to work in $\mathcal{O} \log n$.
We call this new iterator \textit{Trieiteraor} because it represents the relationship as a trie, see~\cref{fig:trie-example}.

The implementation of a \textit{Trieiterator} backed by a columnwise representation of the relation using one array
per column is straight forward, we outline the basic ideas next and refer to the interested reader to
\texttt{leapfrogTriejoin.ArrayTrieIterable.TrieIteratorImpl} in our repository for further details.  % CODEREF
It helps to think about the \textit{Trieiterator} as consisting out of a linear component, containing the functions
\textit{key}, \textit{next} and \textit{seek}, and horizontal component, made off the functions \textit{up} and \textit{down},
to move the linear component from one trie level to another.
First, we explain the horizontal component.
They keep track of the current \textit{level} of the \textit{Trieiterator} and the \textit{startPosition} and \textit{endPosition}
for in the columns,
e.g. in~\cref{fig:trie-example} when the current \textit{level} is 1 (or x) and the key equals 4 the \textit{startPosition} is 2 and
the \textit{endPosition} is 5 because the value 4 occurs 3 times.
With these bookkeeping variables, updated by \textit{up} and \textit{down}, one can implement the linear part by
a binary search over the current column (given by \textit{level}) which is limited to \textit{startPosition} and \textit{endPosition}.

\begin{figure}
    \centering
    \includesvg[height=5cm]{trie}
    \caption{A 3-ary relationship as table (left) and trie (right), to position the iterator at the tuple (1, 1, 5) one
    calls \textit{down} twice, \textit{key} returns now 5, after a call to \textit{next}, \textit{key} returns 6 and \textit{up}
    would lead to \textit{key} returning 1.}
    \label{fig:trie-example}
\end{figure}


% LeapfrogTriejoin  (cite to LFTJ2012)
%    implementation of a state machine to iterate the tries

% Optimizations
%  no use of scala collections and foreach, instead while and arrays
%  move indirections out of the critical path, e.g. by subclassing Spark's columnvector class to allow direct access to underlying array
%  use linear search under threshold (experiments show that there is no big change in performance between 30 to 120 with peak for 60, and lower performance for 400 and 0)
%  implement smallest possible version of lub and linear search
%  no sorting
%  state machine unrolling and predication not helpful
%  reimplement in java not helpful

\subsection{User interface}\label{subsec:user-interface}
\begin{listing}[H]
    \inputminted{scala}{code/usage-example.scala}
    \caption{Example usage of a WCOJ to find triangles in graph.}
    \label{lst:usage-example}
\end{listing}

As one can see in line 16 % LINE
of~\cref{lst:usage-example}, we support a clean and precise DSL to match patterns in graphs.
This DSL is inspired by GraphFrames~\cite{graph-frames}.
The user can define a pattern by its edges, each edge is written as \texttt{(a) - [] -> (b)} where \texttt{a} is the
source vertice and \texttt{b} is the destination, multiple edges are separated by a semicolon.
A connected pattern is expressed by defining multiple edges with the same source or destination.
One should be aware, that a named source or destination is not guaranteed to be a distinct element in the graph,
e.g. \texttt{(a) - [] -> (b); (b) - [] -> (c)} could be a linear path of size two or a circle between \texttt{a} and
\texttt{b}; in the second case \texttt{a} and \texttt{c} are the same element.
The reader might wonders, why we chose to stay with the GraphFrame syntax for edges of
\texttt{- [] ->}, although, we could have went with something simpler, like \texttt{->}.
However, sticking to the more verbose syntax allows us to include labels inside of the squared brackets
in future extensions, e.g. for our stretch goal of integration with CAPS.

The second parameter to \texttt{findPattern} allows the user to specify the variable ordering used in the WCOJ algorithm.
Furthermore, the user interface takes multiple optional arguments, e.g. to apply to common filters to the output of the result,
specify different relationships to be used as input for each edge of the pattern.
The filters are \texttt{distinctFilter}, ensuring that each vertice can occur only as binding for one variable, and
\texttt{smallerThanFilter} to allow only output bindings were the values decrease with regards to the specified variable ordering,
e.g. the binding \texttt{[1, 2, 3]} but not \texttt{[2, 1, 3]} for the triangle query above.
We experienced that these queries are typical for graph queries and that the performance greatly benefits from pushing
them into the join.
Implementing the possibility to push general filters into the join would be a valuable addition but we decided against it because
it a pure engineering task.


\subsection{Spark integration}\label{subsec:spark-integration}

% Logical operator => WCOJ
%   Attribute creation?
%   pattern parsing?
% Strategy => WCOJ2WCOJExec also generating the ToTrieIterableRDDExec children
% Physical operator => WCOJExec
%   general zip partitions?
% Physical operator, ToTrieIterableRDDExec
%    use ensure childOrdering to enforce sorting
%    builds a TrieIterableRDD which is an RDD with TrieIterable partitions
%    building these is a simple matter of adding all rows of each input RDD partition to one array as output partition
%    from this array I can use TrieIteratorImpl to iterate these arrays in a trie form as explained in ref

% JoinSpecification?  move to leapfrogJoin???
% patterns?  move to LeapfrogJoin???


\subsubsection{Graph pattern sequential version (\texttt{graph-pattern-seq})}
